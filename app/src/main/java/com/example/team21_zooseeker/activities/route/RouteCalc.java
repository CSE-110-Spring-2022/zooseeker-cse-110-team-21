package com.example.team21_zooseeker.activities.route;

import android.content.Context;

import com.example.team21_zooseeker.helpers.ZooData;
import com.example.team21_zooseeker.activities.directions.DirectionItem;

import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class RouteCalc {
    private Graph<String, IdentifiedWeightedEdge> g;
    private Map<String, ZooData.VertexInfo> vInfo;
    private Map<String, ZooData.EdgeInfo> eInfo;
    public ArrayList<DirectionItem> directions;

    public RouteCalc(Context context){
        // 1. Load the graph...
        g = ZooData.loadZooGraphJSON(context, "sample_zoo_graph.json");

        // 2. Load the information about our nodes and edges...
        vInfo = ZooData.loadVertexInfoJSON(context, "sample_node_info.json");
        eInfo = ZooData.loadEdgeInfoJSON(context, "sample_edge_info.json");
    }

    /**
     * initialDirections
     *
     * @param start The starting location of each route
     * @param exhibits The users selection of exhibits to see
     * @return List of formatted strings to display directly after hitting 'plan'
     *
     * Each String in the returned list is formatted as ExhibitName, [number]ft
     * ex, "Alligators, 120.0ft"
     *
     *  Calls: calculateRoute
     */
    List<String> initialDirections(String start, List<String> exhibits){

        //calculateRoute handles the algorithm, here we just parse its return into Strings
        List<GraphPath<String, IdentifiedWeightedEdge>> route = calculateRoute(start, exhibits);
        List<String> dispStrings = new ArrayList<String>();

        //We accumulate the total weight of the paths as we go
        double weight = 0;
        for(GraphPath<String, IdentifiedWeightedEdge> path : route){
            weight += path.getWeight();
            String exhibit = vInfo.get(path.getEndVertex()).name;

            dispStrings.add(exhibit + ", " + weight + "ft");
        }
        return dispStrings;
    }

    /**
     * calculateRoute
     *
     * @param start Starting location of each route
     * @param exhibits The users selection of exhibits to see
     * @return A list of graph-paths outlining an efficient route to see
     * each exhibit once, then return back to the start
     *
     * Calls: findNextClosestExhibit
     */
    List<GraphPath<String, IdentifiedWeightedEdge>> calculateRoute(String start, List<String> exhibits){
        List<GraphPath<String, IdentifiedWeightedEdge>> route =
                new ArrayList<GraphPath<String, IdentifiedWeightedEdge>>();

        //Tells us where we currently are in the route
        String current = start;

        //will become path from current to next vertex
        GraphPath<String, IdentifiedWeightedEdge> nextPath = null;

        while((nextPath = findNextClosestExhibit(current, exhibits)) != null){
            route.add(nextPath);
            current = vInfo.get(nextPath.getEndVertex()).id; //current updated to reflect location at end of path
            exhibits.remove(current); //since we are now at current, it has been visited and can be removed from the list
        }

        //We need to add one last path, from our current location back to the start
        route.add(DijkstraShortestPath.findPathBetween(g, current, start));

        //check logcat.D to see whats going on
        getDirections(route);

        return route;
    }

    /**
     * findNextClosestExhibit
     *
     * @param current The vertex we are currently at
     * @param exhibits A list of exhibits we have yet to visit (NOT the user selection list)
     * @return A graph-path from current, to the next closest node in exhibits
     */
    GraphPath<String, IdentifiedWeightedEdge> findNextClosestExhibit(String current, List<String> exhibits){
        //Classic find min, we are finding min weight from current to each exhibit in the list
        double minWeight = Double.MAX_VALUE;
        GraphPath<String, IdentifiedWeightedEdge> nextPath = null;
        for(String exhibit : exhibits) {

            GraphPath<String, IdentifiedWeightedEdge> path = DijkstraShortestPath.findPathBetween(g, current, exhibit);
            if(path.getWeight() < minWeight){
                minWeight = path.getWeight();
                nextPath = path;
            }
        }
        return nextPath;
    }

    /**
     * printDebugInfo
     *
     * @param route graph-path list generated by calculateRoute
     *
     * Prints out the graph-path list, with node names, proper to-from direction,
     * and distance. Entries in the list are clearly demarcated in the output.
     * Calls to System.out.print are put in logcat.Debug
     */
    private void printDebugInfo(List<GraphPath<String, IdentifiedWeightedEdge>> route){
        for(GraphPath<String, IdentifiedWeightedEdge> path : route){
            int count = 1;

            List<String> vertices = path.getVertexList();
            int size = vertices.size();
            String str = "";
            for(int i = 0; i < size-1; i++){
                IdentifiedWeightedEdge e = g.getEdge(vertices.get(i), vertices.get(i+1));
                str += String.format("  %d. Walk %.0f meters along %s from '%s' to '%s'.\n",
                        count,
                        g.getEdgeWeight(e),
                        eInfo.get(e.getId()).street,
                        vInfo.get(vertices.get(i)).name,
                        vInfo.get(vertices.get(i+1)).name);
                count++;
            }
            System.out.println(new DirectionItem(vInfo.get(path.getEndVertex()).name, str).toString());
            System.out.printf("-------------------------------------------\n");
        }
    }

    public void getDirections(List<GraphPath<String, IdentifiedWeightedEdge>> route){
        directions = new ArrayList<DirectionItem>();
        for(GraphPath<String, IdentifiedWeightedEdge> path : route) {
            int count = 1;
            List<String> vertices = path.getVertexList();
            int size = vertices.size();
            String str = "";
            String exhibitName = vInfo.get(path.getEndVertex()).name;

            for(int i = 0; i < size-1; i++){
                IdentifiedWeightedEdge e = g.getEdge(vertices.get(i), vertices.get(i+1));
                str += String.format("%d. Walk %.0f meters along %s from '%s' to '%s'.\n",
                        count,
                        g.getEdgeWeight(e),
                        eInfo.get(e.getId()).street,
                        vInfo.get(vertices.get(i)).name,
                        vInfo.get(vertices.get(i+1)).name);

                if (i != size - 2)
                    str += "\n";

                count++;
            }
            directions.add(new DirectionItem(exhibitName, str));
        }
    }

    /**
     * singleShortestPath
     * @param start Node to start at
     * @param goal Node to get to
     *
     * Not called anywhere, but it was provided and
     * can be referred back to if needed.
     * Note: Since it calls specifically for edge source and edge target,
     * it may output to traverse an edge the wrong way! Remember, the graph is
     * undirected.
     */
    void singleShortestPath(String start, String goal){

        GraphPath<String, IdentifiedWeightedEdge> path = DijkstraShortestPath.findPathBetween(g, start, goal);
        System.out.printf("The shortest path from '%s' to '%s' is:\n", start, goal);

        int i = 1;
        for (IdentifiedWeightedEdge e : path.getEdgeList()) {
            System.out.printf("  %d. Walk %.0f meters along %s from '%s' to '%s'.\n",
                    i,
                    g.getEdgeWeight(e),
                    eInfo.get(e.getId()).street,
                    vInfo.get(g.getEdgeSource(e).toString()).name,
                    vInfo.get(g.getEdgeTarget(e).toString()).name);
            i++;
        }
    }
}
